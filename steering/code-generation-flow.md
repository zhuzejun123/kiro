---
inclusion: always
---

# 完整开发流程（需求 → 代码）

## 全局约束（强制遵循）

参考规范：#[[file:general.md]]

1. **架构文档内容边界**: 接口入参出参不放架构需求文档，放技术方案文档
2. **图表格式**: 流程图使用 `sequenceDiagram`，状态机使用 `stateDiagram-v2`
3. **代码分层**: Manager 层不写代码，外部服务调用放 Core 层的 Adapter 类
4. **文档本地化**: 架构需求和技术方案文档必须写入 `docs/{功能模块}/` 目录
5. **验证器注解**: message 必须使用中文
6. **VO 字段注释**: 必须添加详细 JavaDoc（用于 API Doc 生成）
7. **API 文档**: Controller 代码生成后必须同步生成 API 文档到 `api/` 目录

---

## 流程概览

```
Phase 0: 需求预处理（非标需求 → 结构化需求）
    ↓ 用户确认
Phase 1: 架构需求分析（结构化需求/PRD → 架构需求文档）
    ↓ 用户确认
Phase 2: 技术方案设计（架构需求 → 技术方案文档）
    ↓ 用户确认
Phase 3: 代码生成
    Step 1: DAO 层 → 用户确认
    Step 2: Core 层（三次确认）→ 用户确认
    Step 3: Interfaces 层 → 用户确认
    Step 4: API 层（如需）→ 用户确认
    Step 5: API 文档生成
    Step 6: 单元测试生成（可选）
```

---

## Phase 0: 需求预处理

参考规范：#[[file:requirements-preprocessing.md]]

**适用场景**: 非标准格式的需求输入
- 钉钉聊天记录
- 钉钉文档复制内容
- 口头描述
- 邮件内容
- 会议纪要
- 图片（原型图、流程图、截图）
- 混合内容

**处理流程**:
1. 识别输入类型（聊天/文档/图片/口头/混合）
2. 提取关键信息，过滤噪音
3. 整理为结构化需求描述
4. 列出不清晰/缺失的信息
5. 等待用户确认和补充

**图片处理说明**:
- 无法直接访问外部图片 URL，需用户上传到聊天窗口
- 支持分析：界面原型、流程图、表格截图、聊天截图、架构图

**输出**: 结构化需求描述

**完成后询问**: "我整理了您的需求，请确认理解是否正确？有哪些需要补充？确认后继续生成架构需求文档。"

**跳过条件**: 如果用户提供的是标准 PRD 文档，可直接进入 Phase 1

---

## Phase 1: 架构需求分析

参考规范：#[[file:requirements-analysis.md]]

**输入**: 结构化需求描述 或 标准 PRD 文档

**输出**: 架构需求文档（写入 `docs/{功能模块}/01-architecture-requirements.md`），包含：
- 业务概述与边界
- 参与者（内部/外部，每个参与者至少关联 2 个用例）
- 用例（前置条件、主流程、备选流程、后置条件）
- 业务流程图（sequenceDiagram）
- 状态机（stateDiagram-v2）
- 定时/周期任务
- 外部依赖（二方RPC、三方API）
- 实体关系图
- 非功能性要求
- 业务约束

**完成后询问**: "架构需求文档已完成，请确认以下内容是否正确：
1. 参与者是否完整？
2. 用例是否覆盖所有场景？
3. 状态流转是否正确？
4. 外部依赖是否明确？

确认后继续生成技术方案文档。"

---

## Phase 2: 技术方案设计

参考规范：#[[file:technical-design.md]]

**输入**: 已确认的架构需求文档

**输出**: 技术方案文档（写入 `docs/{功能模块}/02-technical-design.md`），包含：
- 整体架构图（sequenceDiagram）
- 模块拆分（依据、详情、职责）
- 数据模型设计（DDL、DML、索引）
- ER 实体关系图（erDiagram，必须）
- 代码结构设计（包结构、类设计）
- UML 类图（classDiagram，策略/扩展点场景必须）
- 数据流向（核心流程数据传递路径）
- 接口/函数设计
- 外部依赖清单（需用户确认/补充）
- 核心流程实现细节
- 测试与验证要求
- 预生成代码清单

**完成后询问**: "技术方案文档已完成，请确认以下内容：
1. 整体架构是否合理？
2. 数据模型设计是否正确？
3. 接口设计是否完整？
4. 外部依赖信息是否需要补充？

确认后开始分层生成代码。"

---

## Phase 3: 代码生成

### Step 1: DAO 层（数据访问层）

参考规范：#[[file:dao.md]]

**生成内容**:
1. DDL 语句（CREATE TABLE / ALTER TABLE）
2. DML 语句（如需初始化数据）
3. DO 实体类
4. Mapper 接口
5. Mapper XML 文件

**确认要点**:
- [ ] 表结构设计是否正确？
- [ ] 字段类型、长度是否合适？
- [ ] 索引设计是否合理？
- [ ] DO 字段映射是否正确？

**完成后询问**: "DAO 层代码已生成，请确认：
1. 表结构是否需要调整？
2. DO 实体是否正确？

确认后继续生成 Core 层。"

---

### Step 2: Core 层（核心业务层）

参考规范：#[[file:core.md]]

**Core 层代码生成前必须完成三次确认**：

#### 确认一：用例模型确认

```markdown
## 用例模型确认

### 1. 参与者清单
| 参与者 | 类型 | 交互说明 |
|--------|------|----------|

### 2. 用例清单
| 用例编号 | 用例名称 | 参与者 | 业务目标 |
|----------|----------|--------|----------|

### 3. 用例关系图
（描述用例间的包含、扩展、泛化关系）

### 4. 拆分理由
（说明为什么这样识别参与者和用例）

请确认以上用例模型是否完整，如需调整请说明。
```

#### 确认二：分层拆分确认

```markdown
## 分层拆分确认

### 1. 分层结构
| 层级 | Service 名称 | 承接用例 | 核心职责 |
|------|--------------|----------|----------|
| 应用层 | {业务域}Service | 全部用例 | 流程编排、对外统一入口 |
| 核心业务层 | {子模块}Service | 核心用例 | 业务规则、状态流转 |
| 适配层 | {业务域}AdapterService | 外部对接用例 | API封装、多平台适配 |
| 基础层 | {业务域}BaseService | 通用能力 | 校验、工具、规则 |

### 2. 拆分理由
（说明为什么这样分层，每层承接哪些用例要素）

### 3. 层间依赖关系
（描述各层之间的调用关系）

请确认以上分层设计是否合理，如需调整请说明。
```

#### 确认三：Service 方法确认

```markdown
## Service 树结构与方法确认

### 1. 目录结构
finance-core/src/main/java/com/dahuangf/finance/core/{业务域}/
├── bo/
├── enums/
├── contracts/（如有策略接口）
├── validate/（如有校验类）
├── service/
│   └── {子模块}/
│       └── {子模块}Service.java
├── {业务域}Service.java
├── {业务域}BaseService.java
└── {业务域}AdapterService.java

### 2. 各 Service 方法清单

#### {业务域}Service（应用层）
| 方法名 | 入参 | 出参 | 职责说明 | 调用链路 |
|--------|------|------|----------|----------|

#### {业务域}BaseService（基础层）
| 方法名 | 入参 | 出参 | 职责说明 |
|--------|------|------|----------|

#### {业务域}AdapterService（适配层）
| 方法名 | 入参 | 出参 | 职责说明 |
|--------|------|------|----------|

#### {子模块}Service（核心业务层）
| 方法名 | 入参 | 出参 | 职责说明 |
|--------|------|------|----------|

### 3. 调用关系图
（描述各 Service 之间的调用关系）

请确认以上 Service 结构和方法设计是否满足需求，如需调整请说明。
```

**三次确认完成后，生成内容**:
1. BO 业务对象
2. Enum 枚举类
3. Service 类（应用层、基础层、适配层、核心业务层）
4. 策略接口/校验类（如有）

**外部依赖确认**:

| 依赖类型 | 依赖名称 | 需要信息 | 状态 |
|----------|----------|----------|------|
| 二方 RPC | [服务名] | 全路径包名、方法签名 | ⏳ 待确认 |
| 三方 API | [API名] | 接口文档、认证方式 | ⏳ 待确认 |

**无法提供时**: 代码中预留 `// TODO: 待对接 [依赖名称]`

**完成后询问**: "Core 层代码已生成，请确认：
1. 业务逻辑是否正确？
2. 外部依赖调用是否正确？
3. 是否有遗漏的业务场景？

确认后继续生成 Interfaces 层。"

---

### Step 3: Interfaces 层（Web 层/Controller）

参考规范：#[[file:interfaces.md]]

**生成内容**:
1. PageReqVO 分页查询对象（继承 PageParam，实现 IQuery）
2. CreateReqVO 新增请求对象
3. UpdateReqVO 更新请求对象（继承 CreateReqVO，实现 UpdateVO）
4. RespVO 响应对象
5. Controller 控制器

**VO 规范要点**:
- 验证器注解 message 必须使用中文
- 所有字段必须添加详细 JavaDoc 注释（用于 API Doc 生成）
- 金融字段（金额、成本、价格等）必须添加 `@Price` 注解
- PageReqVO 字段使用 `@Condition` 注解，String 类型必须用 `Operator.eq`

**确认要点**:
- [ ] HTTP 接口路径是否合理？
- [ ] 请求/响应参数是否完整？
- [ ] 参数校验是否充分？
- [ ] 是否需要额外的查询接口？

**完成后询问**: "Interfaces 层代码已生成，请确认：
1. HTTP 接口是否满足需求？
2. 是否需要补充其他接口？

是否需要生成 API 层（对外 RPC 能力）？"

---

### Step 4: API 层（对外接口定义，可选）

参考规范：#[[file:api.md]]

**执行条件**: 仅当需要对外提供 RPC 能力时执行

**生成内容**:
1. TO 传输对象（实现 Serializable）
2. RPC 接口定义（返回 RpcResult 包装）
3. RPC 接口实现（在 {MODULE}-interfaces/rpc/ 目录）

**确认要点**:
- [ ] RPC 接口是否满足调用方需求？
- [ ] TO 对象字段是否完整？
- [ ] 是否需要额外的 RPC 方法？

---

### Step 5: API 文档生成

参考规范：#[[file:interfaces.md]] 中的「API 文档生成规范」

**执行条件**: Controller 代码生成完成后必须执行

**输出位置**: `api/{业务域}-api.md`

**路径拼接规则**:
完整接口路径 = `/finance-platform` + `@RequestMapping` + 方法注解路径

**文档格式**:
每个接口包含：接口路径、请求方式、接口说明、请求参数、响应参数

**完成后询问**: "API 文档已生成，是否需要生成单元测试代码？"

---

### Step 6: 单元测试生成（可选）

参考规范：#[[file:test.md]]

**执行条件**: 用户确认需要生成单元测试时执行

**生成流程**:

#### 6.1 检查并创建 BaseTest

**路径**: `{MODULE}-interfaces/src/test/java/{BASE_PACKAGE}/test/BaseTest.java`

- 如果存在：跳过，继续下一步
- 如果不存在：先创建 BaseTest.java

```java
package {BASE_PACKAGE}.test;

import {BASE_PACKAGE}.interfaces.Application;
import org.junit.runner.RunWith;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class BaseTest {

}
```

#### 6.2 分析被测类

1. 识别被测类的所有公共方法
2. 分析每个方法的业务逻辑
3. 识别依赖的外部组件（需要 Mock）

#### 6.3 设计测试用例

输出测试用例清单，等待用户确认：

```markdown
## {类名} 测试用例清单

### {方法名} 方法

| 用例编号 | 场景描述 | 输入 | 预期结果 | 优先级 |
|----------|----------|------|----------|--------|
| TC-001 | 正常流程 | 有效参数 | 成功 | P0 |
| TC-002 | 业务规则校验失败 | 无效参数 | 抛出 BizException | P0 |
| TC-003 | 边界条件 | 边界值 | 预期行为 | P1 |
```

**确认后继续生成测试代码**

#### 6.4 生成测试代码

**生成内容**:
1. 业务域文件夹（如 `invoice/`）
2. 测试类（继承 BaseTest，使用 @Resource 注入）
3. 测试方法（每个方法必须有 @Test 注解）
4. 测试数据构建方法
5. Fixture 工厂类（复杂场景）

**测试目录结构**:
```
{MODULE}-interfaces/src/test/java/{BASE_PACKAGE}/test/
├── BaseTest.java                # 测试基类（如不存在则先创建）
└── {业务域}/
    ├── {类名}Test.java          # 继承 BaseTest，方法必须有 @Test
    └── fixture/
        └── {业务域}Fixture.java（可选）
```

**测试覆盖要求**:
| 场景类型 | 优先级 |
|----------|--------|
| 正常流程 | P0（必须） |
| 参数校验 | P0（必须） |
| 业务规则 | P0（必须） |
| 边界条件 | P1 |
| 异常处理 | P1 |
| 空值处理 | P2 |

**完成后**: "所有代码生成完毕！

生成文件清单：
- DAO 层: [文件列表]
- Core 层: [文件列表]
- Interfaces 层: [文件列表]
- API 层: [文件列表]
- API 文档: [文件路径]
- 单元测试: [文件列表]

请检查生成的代码，如有问题随时告诉我。"

---

## 快速参考

| 阶段 | 输入 | 输出 | 确认点 |
|------|------|------|--------|
| Phase 0 | 非标需求 | 结构化需求描述 | 理解是否正确、信息补充 |
| Phase 1 | 结构化需求/PRD | 架构需求文档 | 用例、状态机、依赖 |
| Phase 2 | 架构需求 | 技术方案文档 | 架构、数据模型、接口 |
| Step 1 | 技术方案 | DAO 代码 | 表结构、DO |
| Step 2 | DAO 代码 | Core 代码 | 用例模型、分层拆分、Service 方法 |
| Step 3 | Core 代码 | Interfaces 代码 | HTTP 接口、VO |
| Step 4 | Interfaces 代码 | API 代码 | RPC 接口 |
| Step 5 | Controller | API 文档 | 接口文档完整性 |
| Step 6 | 业务代码 | 单元测试 | 测试用例覆盖度 |

---

## 使用方式

### 方式一：非标需求（钉钉聊天、口头描述、图片等）
1. 粘贴钉钉聊天记录/文档内容/描述需求/上传图片
2. 我整理为结构化需求 → 你确认
3. 我生成架构需求文档 → 你确认
4. 我生成技术方案文档 → 你确认
5. 我按 DAO → Core → Interfaces → API 顺序生成代码
6. Core 层需要三次确认（用例模型、分层拆分、Service 方法）
7. 每层代码生成后等待你确认再继续
8. 生成 API 文档
9. 可选：生成单元测试代码

### 方式二：标准 PRD 文档
1. 提供 PRD 文档内容
2. 跳过 Phase 0，直接生成架构需求文档 → 你确认
3. 后续流程同上

**开始**: 请提供你的需求（可以是钉钉聊天记录、文档内容、图片、或直接描述）。
